---
title: "Homework Bird FeederWatch Data"
format: html
editor: visual
---

```{r}

if(!require(pacman))
  install.packages("pacman")

pacman::p_load(
  C50,                # C5.0 Decision Trees and Rule-Based                            # Models
  caret,              # Classification and Regression Training
  e1071,              # Misc Functions of the Department of Statistics (e1071), TU Wien
  keras,              # R Interface to 'Keras'
  kernlab,            # Kernel-Based Machine Learning Lab
  lattice,            # Trellis Graphics for R
  MASS,               # Support Functions and Datasets for Venables and Ripley's MASS
  mlbench,            # Machine Learning Benchmark Problems
  nnet,               # Feedforward Neural Networks and Multinomial Log-Linear Models
  palmerpenguins,     # Palmer Archipelago (Antarctica) Penguin Data
  party,              # A Laboratory for Recursive Partytioning
  partykit,           # A Toolkit for Recursive Partytioning
  randomForest,       # Breiman and Cutler's Random Forests for Classification and Regression
  FSelector,          # This will bring in "RWeka & also randomForest, et al." 
  rJava,              # I think this is needed for RWeka so I'll add it here
  rpart,              # Recursive partitioning models
  RWeka,              # R/Weka Interface
  scales,             # Scale Functions for Visualization
  tidymodels,         # Tidy machine learning framework
  tidyverse,          # Tidy data wrangling and visualization
  xgboost,             # Extreme Gradient Boosting
  snow,
  dlookr, # Exploratory data analysis
  forecast, # Needed for Box-Cox transformations
  formattable, # HTML tables from R outputs
  here, # Standardizes paths to data
  kableExtra, # Alternative to formattable
  knitr, # Needed to write HTML reports
  missRanger, # To generate NAs
  tidyverse) # Powerful data wrangling package suite

### Install packages: Show fewer digits ###

options(digits=3)
```

**Dataset 1**

```{r}
### Load raw data.

dataset1 <- read_csv(here('PFW_2021_public.csv'))

dataset1 |>
  #head() |>
  diagnose() |> # 361 birds (species_code)
  formattable()

dataset1

dataset1 |> summary()

dataset1 |> # Table of N/A values. Only 3 which I have since removed: snow_dep_atleast, entry_technique, effort_hrs_atleast	
  plot_na_pareto(only_na = TRUE, plot = FALSE) |>
  formattable() # Publishable table

dataset1 |> # I like this plot.
  plot_na_pareto(only_na = TRUE)

dataset1 |> # Don't like this plot.
  plot_na_intersect(only_na = TRUE)

dataset1 <- dataset1 |>
##dataset.no_NAs_1 <- dataset1 |> 
  drop_na()

dataset1 |>
  diagnose_category() |>
  formattable()

# Plot showing the results of our imputation
#rpart_na_imp_insulin |>
#  plot()
```

Dataset 1 - Observations of 10 species of birds were taken from 9 states in the US (NY, PA, VA, CA, MA, TX, OH, NC, MI) and 1 state in Canada (Ontario).

I could combine the data based on vegetation that's observed in Dataset 2 with the longitude and latitude. So given a bird species which area/state would you most likely find it in?

```{r}

# All 62 columns in the dataset:
#
#         loc_id,
#         proj_period_id,	
#         yard_type_pavement,
#         yard_type_garden,
#         yard_type_landsca,
#         yard_type_woods,
#         yard_type_desert,
#         hab_dcid_woods,
#         hab_evgr_woods,
#         hab_mixed_woods,
#         hab_orchard,
#         hab_park,
#         hab_water_fresh,
#         hab_water_salt,
#         hab_residential,
#         hab_industrial,
#         hab_agricultural,
#         hab_desert_scrub,
#         hab_young_woods,
#         hab_swamp,
#         hab_marsh,
#         evgr_trees_atleast,
#         evgr_shrbs_atleast,
#         dcid_trees_atleast,	
#         dcid_shrbs_atleast,
#         fru_trees_atleast,
#         cacti_atleast,
#         brsh_piles_atleast,
#         water_srcs_atleast,
#         bird_baths_atleast,
#         nearby_feeders,
#         squirrels,
#         cats,
#         dogs,
#         humans,
#         housing_density,
#         fed_yr_round,
#         fed_in_jan,
#         fed_in_feb,
#         fed_in_mar,
#         fed_in_apr,	
#         fed_in_may,
#         fed_in_jun,
#         fed_in_jul,
#         fed_in_aug,
#         fed_in_sep,
#         fed_in_oct,
#         fed_in_nov,
#         fed_in_dec,
#         numfeeders_suet,
#         numfeeders_ground,
#         numfeeders_hanging,
#         numfeeders_platfrm,
#         numfeeders_humming,
#         numfeeders_water,
#         numfeeders_thistle,
#         numfeeders_fruit,
#         numfeeders_hopper,
#         numfeeders_tube,
#         numfeeders_other,
#         population_atleast,
#         count_area_size_sq_m_atleast)

dataset2 <- read_csv(here('PFW_count_site_data_public_2021.csv'))

dataset2 <- as_tibble(dataset2)
dataset2 |> glimpse()

dataset2 |>
  head() |>
  formattable()
dataset2

###tree_default <- dataset2 |> # Need to remove N/A columns.
###    rpart(type ~ ., data = _)
###tree_default

###fit <- rpart(dataset2)
###na.rpart(fit)


# fed_data_all_months <- data.frame(dataset2) |>

#dataset2 %>%
#  select(fed_in_apr) #|>
#  ifelse(data == 1, TRUE, FALSE)

#dataset2 <- dataset2 |> # If converting binary data to T/F, use this.
#  mutate(across(where(is.numeric), factor, levels = c(TRUE, FALSE))) |>
#  mutate(across(where(is.character), factor))
# Data type is already factor, so no need to use this.

dataset2 |> summary()
```

```{r}
notbad_ok_data <- dataset2 |> # This is the table that guides you on what values to remove.
  plot_na_pareto(only_na = TRUE, plot = FALSE) |>
  formattable()
notbad_ok_data
```

```{r}

dataset2 |> # This is the plot that will guide you on what to remove.
  plot_na_pareto(only_na = TRUE)
```

```{r}

dataset2 |> # Don't like this plot.
  plot_na_intersect(only_na = TRUE)

dataset2 |>
  diagnose_category() |>
  formattable()

fed_yr_round_data <- dataset2 %>%
  select(loc_id,
         proj_period_id,
         fed_in_apr,
         fed_in_aug,
         fed_in_dec,
         fed_in_feb,
         fed_in_jan,
         fed_in_jul,
         fed_in_jun,
         fed_in_mar,
         fed_in_may,
         fed_in_nov,
         fed_in_oct,
         fed_in_sep) #|>
    #diagnose_category() |>
  #formattable()

fed_yr_round_data <- dataset2 %>%
  diagnose_category() |>
    formattable()
fed_yr_round_data

fit <- rpart(fed_yr_round_data) #This WILL produce a decision tree.
fit

tree_default <- fed_yr_round_data |> 
  rpart(type ~ ., data = _)
tree_default

tree_full <- fit |> 
  rpart(type ~ . , data = _, 
        control = rpart.control(minsplit = 2, cp = 0))
rpart.plot(tree_full, extra = 2, 
           roundint=FALSE,
            box.palette = list("Gy", "Gn", "Bu", "Bn", 
                               "Or", "Rd", "Pu")) # specify 7 colors

fed_data_all_months <- data.frame(dataset2) |>
  group_by(proj_period_id, fed_in_apr, fed_in_may, fed_in_jun, fed_in_aug, fed_in_dec, fed_in_feb, fed_in_jan, fed_in_jul, fed_in_mar, fed_in_nov, fed_in_oct, fed_in_sep) |>
    summarise.groups(count = n())
fed_data_all_months

fed_in_apr_data <- dataset2|>
  group_by("fed_in_apr", "fed_in_may") |>
    summarise(count = n())

fed_in_apr_data
```

*Dataset 2 - Observation of unknown areas that account for plants, creatures, habitat, water, etc., throughout the years 2001-2020, which has a lot of gaps in the data.*

*Once I narrow down the data to reliable data, then we can ask, "Can the birds that were observed in Dataset 1 live in the lands listed in Dataset 2?"*

```{r}

dataset2 <- read_csv(here('PFW_count_site_data_public_2021.csv'))

dataset2 <- as_tibble(dataset2)
dataset2 |> glimpse()

summary(dataset2)

fed_yr_round_data <- dataset2 %>%
  select(#fed_in_apr,
         fed_in_aug,
         fed_in_dec,
         fed_in_feb,
         fed_in_jan,
         fed_in_jul,
         fed_in_jun,
         fed_in_mar,
         fed_in_may,
         fed_in_nov,
         fed_in_oct,
         fed_in_sep)

fit <- rpart(fed_yr_round_data)
fit

library(rpart.plot)
rpart.plot(fit, extra = 2)

```

See how much feeding has been done throughout the months over the years.

Think about amount of trees, predators (who will compete for food), etc.
